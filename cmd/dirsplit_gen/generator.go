// Package main implements a source generator which was mostly adapted from
// this dev.to article: https://dev.to/hlubek/metaprogramming-with-go-or-how-to-build-code-generators-that-parse-go-code-2k3j
package main

import (
	"fmt"
	"go/types"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

func main() {
	// HACK: As package loading (and as such, source parsing) fails unless we have
	//       the inclusion tag set if the file is mid-generation.
	os.Setenv("GOFLAGS", "-tags=CODEGEN")
	generatedfile := os.Getenv("GOFILE")
	if generatedfile == "" {
		panic("empty gen'd file")
	}
	if generatedfile != "" {
		generatedfile = strings.TrimSuffix(generatedfile, ".go") + ".g.go"
	}

	cleanMode := false
	// 1. Handle arguments to command
	if len(os.Args) != 3 {
		failErr(fmt.Errorf("expected arguments: <source type> <var name|-clean>"))
	}

	if os.Args[2] == "-clean" {
		cleanMode = true
	}

	sourceType := os.Args[1]
	sourceTypePackage, sourceTypeName := splitSourceType(sourceType)

	// 2. Inspect package and use type checker to infer imported types
	pkg := loadPackage(sourceTypePackage)

	if cleanMode {
		// fuck you, pkg.Name is empty for some reason, hardcoded to main
		// because we're never gonna use this anywhere else
		err := os.WriteFile(generatedfile, []byte(fmt.Sprintf("// Code generated by dirsplit_gen. DO NOT EDIT.\n//go:build !(editor || CODEGEN)\npackage main\n")), 0777)
		if err != nil {
			panic(fmt.Sprintf("failed to clean up: %+v", err))
		}
		return
	}

	// 3. Lookup the given source type name in the package declarations
	obj := pkg.Types.Scope().Lookup(sourceTypeName)
	if obj == nil {
		failErr(fmt.Errorf("%s not found in declared types of %s",
			sourceTypeName, pkg))
	}

	// 4. We check if it is a declared type
	var val *types.Const
	var ok bool
	if val, ok = obj.(*types.Const); !ok {
		failErr(fmt.Errorf("%v is not a named const", obj))
	}
	// 5. We expect the underlying type to be a struct
	_, ok = obj.Type().Underlying().(*types.Basic)
	if !ok {
		failErr(fmt.Errorf("type %v is not a Basic type", obj))
	}

	imms := strings.Trim(val.Val().String(), "\"")
	s := strings.Split(imms, " ")

	for i, ss := range s {
		if len(ss) != 0 {
			s[i] = "\"" + ss + "\""
		}
	}

	j := strings.Join(s, ",")
	l := len(s)
	if len(s) == 1 && len(s[0]) == 0 {
		j = ""
		l = 0
	}

	f, err := os.OpenFile(generatedfile, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		if os.IsNotExist(err) {
			panic("must call clean fist!")
		} else {
			panic(err)
		}
	}

	defer f.Close()

	fmt.Fprintf(f, "var %s [%d]string = [%d]string{%s}\n", os.Args[2], l, l, j)
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func splitSourceType(sourceType string) (string, string) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		failErr(fmt.Errorf(`expected qualified type as "pkg/path.MyType"`))
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
